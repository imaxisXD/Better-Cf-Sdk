---
title: Cloudflare vs better-cf
description: Compare native Cloudflare queue workflows with Queue SDK workflow, API shape, and day-to-day DX.
---

import { Code } from '@astrojs/starlight/components';

Compare these two implementation paths for queue-driven Worker development:

- native Cloudflare path (Wrangler + manual queue wiring)
- Queue SDK path (`better-cf/queue` + automation CLI)

## What You Will Achieve

- understand where Queue SDK improves everyday workflow speed
- identify where native Cloudflare remains the better fit
- choose a practical default per team/project stage

## Before You Start

- know your team’s queue workload profile (feature velocity vs low-level control)
- review current boundaries in [Limitations](/limitations)
- know that Queue SDK is currently the shipped Alpha package in the suite

## Step 1: Compare Workflow and DX

<div class="dx-table-wrap">
  <table class="comparison-table">
    <thead>
      <tr>
        <th>Concern</th>
        <th>Cloudflare flow</th>
        <th>better-cf flow</th>
        <th>Why it matters</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td data-label="Concern"><strong>Queue contract definition</strong></td>
        <td data-label="Cloudflare flow">Payload shape is defined by convention or custom validation in handlers.</td>
        <td data-label="better-cf flow"><code>defineQueue(&#123; message: z.object(...) &#125;)</code> centralizes contract and typed producer/consumer usage.</td>
        <td data-label="Why it matters">One source of truth for message shape.</td>
      </tr>
      <tr>
        <td data-label="Concern"><strong>Entry and binding wiring</strong></td>
        <td data-label="Cloudflare flow">Entry exports and Wrangler queue sections are maintained manually.</td>
        <td data-label="better-cf flow"><code>better-cf dev/generate</code> scans queues, generates entry, and patches supported Wrangler configs.</td>
        <td data-label="Why it matters">Less config drift and less repetitive maintenance.</td>
      </tr>
      <tr>
        <td data-label="Concern"><strong>Local dev loop</strong></td>
        <td data-label="Cloudflare flow">Custom watch/rebuild orchestration per team.</td>
        <td data-label="better-cf flow">Single scan → validate → generate → patch → run loop.</td>
        <td data-label="Why it matters">Lower setup overhead for daily development.</td>
      </tr>
      <tr>
        <td data-label="Concern"><strong>Error model</strong></td>
        <td data-label="Cloudflare flow">Error surface varies by command/context.</td>
        <td data-label="better-cf flow">Normalized CLI shape (`code`, `summary`, `details`, `hint`).</td>
        <td data-label="Why it matters">Faster triage and easier team onboarding.</td>
      </tr>
      <tr>
        <td data-label="Concern"><strong>Queue testing</strong></td>
        <td data-label="Cloudflare flow">Custom harness and batch stubs.</td>
        <td data-label="better-cf flow"><code>testQueue</code> runs queue handlers directly in unit tests.</td>
        <td data-label="Why it matters">Shorter feedback loop for queue logic.</td>
      </tr>
    </tbody>
  </table>
</div>

Expected output:

- clear mapping between workflow friction points and SDK automation value

## Step 2: Compare API Surface

<div class="dx-table-wrap">
  <table class="comparison-table">
    <thead>
      <tr>
        <th>Capability</th>
        <th>Cloudflare primitive</th>
        <th>better-cf API</th>
        <th>Notes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td data-label="Capability"><strong>SDK bootstrap</strong></td>
        <td data-label="Cloudflare primitive">Direct Worker runtime + queue bindings.</td>
        <td data-label="better-cf API"><code>createSDK&lt;Env&gt;()</code></td>
        <td data-label="Notes">Returns typed `defineQueue` and `defineWorker` helpers.</td>
      </tr>
      <tr>
        <td data-label="Capability"><strong>Queue definition</strong></td>
        <td data-label="Cloudflare primitive">Custom queue handler structure.</td>
        <td data-label="better-cf API"><code>defineQueue(...)</code></td>
        <td data-label="Notes">Supports push mode, pull config mode, and multi-job mode.</td>
      </tr>
      <tr>
        <td data-label="Capability"><strong>Producer send</strong></td>
        <td data-label="Cloudflare primitive"><code>env.MY_QUEUE.send/sendBatch</code></td>
        <td data-label="better-cf API"><code>queue.send</code> / <code>queue.sendBatch</code></td>
        <td data-label="Notes">Typed payload + delivery/content options.</td>
      </tr>
      <tr>
        <td data-label="Capability"><strong>Worker wrapper</strong></td>
        <td data-label="Cloudflare primitive">Manual `fetch/scheduled` wiring.</td>
        <td data-label="better-cf API"><code>defineWorker(&#123; fetch, scheduled? &#125;)</code></td>
        <td data-label="Notes">Typed context env including generated bindings.</td>
      </tr>
      <tr>
        <td data-label="Capability"><strong>Testing</strong></td>
        <td data-label="Cloudflare primitive">Custom mocks and harnesses.</td>
        <td data-label="better-cf API"><code>testQueue(handle, options)</code></td>
        <td data-label="Notes">Returns `acked`/`retried` assertion arrays.</td>
      </tr>
      <tr>
        <td data-label="Capability"><strong>Admin ops</strong></td>
        <td data-label="Cloudflare primitive">Wrangler queue/subscription commands.</td>
        <td data-label="better-cf API"><code>better-cf queue:&#42;</code> / <code>subscription:&#42;</code></td>
        <td data-label="Notes">Validated wrapper commands over Wrangler.</td>
      </tr>
    </tbody>
  </table>
</div>

Expected output:

- technical API differences are concrete and implementation-relevant

## Step 3: Compare Code Shape

### Manual Cloudflare pattern (common)

<Code
  lang="ts"
  code={`import { z } from 'zod';

type Env = { QUEUE_SIGNUP: Queue };

const signupSchema = z.object({
  email: z.string().email(),
  userId: z.string()
});

export default {
  async fetch() {
    return new Response('ok');
  },
  async queue(batch: MessageBatch<unknown>, env: Env) {
    for (const message of batch.messages) {
      const parsed = signupSchema.safeParse(message.body);
      if (!parsed.success) {
        message.retry();
        continue;
      }
      try {
        await handleSignup(env, parsed.data);
        message.ack();
      } catch {
        message.retry();
      }
    }
  }
};`}
/>

### Queue SDK pattern

<Code
  lang="ts"
  code={`import { createSDK } from 'better-cf/queue';
import { z } from 'zod';

type Env = { QUEUE_SIGNUP: Queue };
const { defineQueue, defineWorker } = createSDK<Env>();

export const signupQueue = defineQueue({
  message: z.object({ email: z.string().email(), userId: z.string() }),
  retry: 3,
  retryDelay: '30s',
  process: async ({ env }, message) => {
    await handleSignup(env, message);
  }
});

export default defineWorker({
  async fetch() {
    return new Response('ok');
  }
});`}
/>

Expected output:

- reduced worker boilerplate and centralized queue behavior definition

<div class="dx-callout">
  <strong>Good to know:</strong> practical default for most app teams is Queue SDK for daily development, with native Cloudflare commands kept for unsupported edge cases.
</div>

## Troubleshooting

### Comparison looks too abstract for your team

Map each row to one current pain point (drift, setup complexity, testing cost) and run one pilot queue with Queue SDK.

### Team needs unsupported runtime behavior

Use native Cloudflare APIs directly for that path while keeping SDK for supported queue workflows.

### Decision blocked by Alpha status

Adopt Queue SDK on bounded workflows first and keep fallback escape hatches explicit in architecture docs.

## Next Steps

- Review command-level operations in [CLI Command Reference](/reference/cli-reference)
- Validate constraints in [Limitations](/limitations)
- Track maturity updates in [Roadmap](/reference/roadmap)

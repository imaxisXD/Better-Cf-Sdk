import fs from 'node:fs';
import path from 'node:path';
import { resolveWorkerEntry } from './config.js';
import type { CliConfig, DiscoveryResult } from './types.js';

export interface CodegenResult {
  entryPath: string;
  typesPath: string;
}

export function generateCode(discovery: DiscoveryResult, config: CliConfig): CodegenResult {
  const outputDir = path.join(config.rootDir, '.better-cf');
  fs.mkdirSync(outputDir, { recursive: true });

  const workerEntryAbsolute = resolveWorkerEntry(config);

  const entryContents = renderEntryFile(discovery, workerEntryAbsolute, outputDir, config);
  const typesContents = renderTypesFile(discovery);

  const entryPath = path.join(outputDir, 'entry.ts');
  const typesPath = path.join(outputDir, 'types.d.ts');

  fs.writeFileSync(entryPath, entryContents, 'utf8');
  fs.writeFileSync(typesPath, typesContents, 'utf8');

  return {
    entryPath,
    typesPath
  };
}

function renderEntryFile(
  discovery: DiscoveryResult,
  workerEntryAbsolute: string,
  outDir: string,
  config: CliConfig
): string {
  const imports: string[] = [];
  const bindings: string[] = [];
  const queueMap: string[] = [];

  imports.push(
    `import workerDefault, * as workerModule from ${JSON.stringify(toImportPath(outDir, workerEntryAbsolute))};`
  );
  imports.push(`import { getQueueInternals, resolveWorkerHandlers } from 'better-cf/queue/internal';`);

  for (const queue of discovery.queues) {
    const queueImportPath = toImportPath(outDir, queue.absoluteFilePath);
    if (queue.isDefaultExport) {
      imports.push(`import ${queue.importName} from ${JSON.stringify(queueImportPath)};`);
    } else {
      imports.push(
        `import { ${queue.exportName} as ${queue.importName} } from ${JSON.stringify(queueImportPath)};`
      );
    }

    bindings.push(`getQueueInternals(${queue.importName}).setBinding('${queue.bindingName}');`);
    queueMap.push(`  '${queue.queueName}': ${queue.importName}`);
  }

  const scheduledBlock = `
const __workerHandlers = resolveWorkerHandlers({ default: workerDefault, ...workerModule });

export default {
  async fetch(request: Request, env: unknown, ctx: ExecutionContext): Promise<Response> {
    return __workerHandlers.fetch(request, env, ctx);
  },

  async queue(batch: MessageBatch<unknown>, env: unknown, ctx: ExecutionContext): Promise<void> {
    const consumer = __queues[batch.queue];
    if (!consumer) {
      console.error(\`[better-cf] No queue consumer for "\${batch.queue}". Acking batch to avoid infinite retries.\`);
      batch.ackAll();
      return;
    }

    await getQueueInternals(consumer).consume(batch, env, ctx);
  },

  ...(__workerHandlers.scheduled
    ? {
        async scheduled(event: ScheduledEvent, env: unknown, ctx: ExecutionContext): Promise<void> {
          await __workerHandlers.scheduled?.(event, env, ctx);
        }
      }
    : {})
};`;

  const legacyWarning = config.legacyServiceWorker
    ? "console.warn('[better-cf] legacyServiceWorker mode is compatibility-only. Consider migrating to module workers.');"
    : '';

  return `// Auto-generated by better-cf. Do not edit.
${imports.join('\n')}

${bindings.join('\n')}

const __queues: Record<string, unknown> = {
${queueMap.join(',\n')}
};

${legacyWarning}
${scheduledBlock}
`;
}

function renderTypesFile(discovery: DiscoveryResult): string {
  const lines = discovery.queues.map((queue) => {
    return `    ${queue.bindingName}: Queue;`;
  });

  return `// Auto-generated by better-cf. Do not edit.
import type { Queue } from '@cloudflare/workers-types';

declare module 'better-cf/queue' {
  interface BetterCfGeneratedBindings {
${lines.join('\n')}
  }

  interface BetterCfAutoEnv extends BetterCfGeneratedBindings {}
}

export {};
`;
}

function toImportPath(fromDir: string, targetFile: string): string {
  const relative = path.relative(fromDir, targetFile).replace(/\\/g, '/');
  if (relative.startsWith('.')) {
    return relative.replace(/\.tsx?$/, '');
  }
  return `./${relative.replace(/\.tsx?$/, '')}`;
}
